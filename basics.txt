we don't add any html in index.html, we inject html from our source folder to the index.html file
we create our components in app.js file and then render those components in index.js file
ReactDOM.render(<App />, document.getElementById('root'));
here App component that is in return a bunch of jsx code is injected in the root element of of index.html file

class App extends Component {
  render() {
    // return (
    //   <div className="App">
    //     <h1>Hi, I am a React App</h1>
    //   </div>
    // );
    // the above code is eventually compiled in React.createElement statment
    // the statment below takes [3,infinite ) number of arguments
    
    return React.createElement(first, second , third);

    /*first: the elemnt we want to render, could be any other imported component 
    Second: configuration, and js object, could be null or {className: App} we tell which css file is to be used
    third: all children inside the first argument like all childer in div*/

    // both above are the methods , but the second method is a bit hard although it is finally what first version is getting compiled to
    // therefore we use {Math.floor(Math.random() * 10)}{Math.floor(Math.random() * 10)}{Math.floor(Math.random() * 10)}{Math.floor(Math.random() * 10)}he first version that is using jsx
  }
}

Restrictions of jsx:
we use className instead of class because it is a js file and class word already has a diffrent meaning in js
also div, h1 are not actually html here ,the react library is converting them

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Components are the core building block of React apps. Actually, React really is just a library for creating components in its core.

A typical React app therefore could be depicted as a component tree - having one root component ("App") and then an potentially infinite amount of nested child components.

Each component needs to return/ render some JSX code - it defines which HTML code React should render to the real DOM in the end.

JSX is NOT HTML but it looks a lot like it. Differences can be seen when looking closely though (for example className in JSX vs class in "normal HTML"). JSX is just syntactic sugar for JavaScript, allowing you to write HTMLish code instead of nested React.createElement(...) calls.

When creating components, you have the choice between two different ways:

    Functional components (also referred to as "presentational", "dumb" or "stateless" components - more about this later in the course) => const cmp = () => { return <div>some JSX</div> } (using ES6 arrow functions as shown here is recommended but optional)
    class-based components (also referred to as "containers", "smart" or "stateful" components) => class Cmp extends Component { render () { return <div>some JSX</div> } } 

We'll of course dive into the difference throughout this course, you can already note that you should use 1) as often as possible though. It's the best-practice.

/////////////////////////////////////////////////////////////////////////////////////////////////
use {} to add valued variables into display text 
{Math.floor(Math.random() * 10)}
<Person name="Broley" age="5">Broke: teeth</Person>
for self made components this is how we pass arguments in functions
(props)=>{return <h1>{props.name} {props.age}</h1> } the general convention is to use props as the object name 
we use this.props in class based components
the above text passes between enclosing person call is accesed in function using {props.children}, this can be anything text,html

state is used in classed based components and used to control vars from inside, state is a js object
// we use this.setState method provided by component and changes the state object
// useSetstate function returns 2 elemnt array where first is the object that sets the state initially and other is the function that changes the state
when we use useState ,the changed object is not merged rather it is replaced, so we have to manually add the unchaged parts of object
we can also send methods as props

we can use this.functionName.bind(this, changed value)
then call the function with the argument and use it to change the state
Method 2 is: this.switchNameHandler --> () => this.switchNameHandler('Broley Siberian')
we don't directly use this.switchNameHandler() becuase it will immediately work as our app loads and we want to only happen on trigger of event

when we want to handle input events
where input is used use onChange={props.methodProvided} 
in main file "changed/any name ={this.theFunctioncreated}"
now the functionCreated is "functionCreated(event){ name: event.target.value }"

//////////////////////////////////////////////////////////////////////////////////////////////////////
this is more of a JS concept
the refrencing of murable data types is a bit diffrent in JS
let ram = [1,1,2]
let laxman = ram;
this means that now laxman point to the same memory of [1,1,2] and not a copy of that array.
to make a copy use "let laxman = [...ram]" or "let laxman = ram.slice()"

strings in Js are not basically arrays
so we need to convert them, this.state.requiredString.split('').map(); so the .split('') converts it in array
use requiredArrayString.join('') so join('') reconverts the char array to one string
 /////////////////////////////////////////////////////////////////////////////////////////////////////

presentational components are those which don't manage state
we should try to keep presentational components/ funtional comonenpts outside of class or in separate modules and only keep function manipulating state inside the main class

lifecycle hoocls have nothing to do with react hooks
dont use constructor to send http requests because that can cause side effects like getting stuck in a dead loop

writing state = {} is the modern syntax
behind the scenes what it does is
it calls the constructor
constructor(props) {
  super(props);
  this.state = {}
}

LIFE CYCLE HOOKS
first function executed is constructor function
then getDerivedStatefromprops (a static method) is called before the render method (used to initialsize state of component with updated props), that is important to note
next method is automatically the render method
no function inside the render method will be called unless the method is invoked
every time the render method is called the getDerivedStatefromprops is also called
at end of everything componentdidmount executes

shouldCompnonentUpdate is a good lige cycle hook that helps us to enhance performance

useEffect is a React hook that can replace almost all the life cycle hooks in functional components
make sure that the func Component is in uppercase to avoid errror
useEffect(function , [restriction]);
and if we want to run it only once, pass an empty array as the function will know that there are no dependencies
useEffect(function , []);

// React.memo stores a snapshot of the functon and if there is no change in the functional component so it will not re-render the component
export default React.memo(Cockpit);

in react we can only have one higher order component wrapping the whole elements, the way around that is by using React.Fragment instead
but we can also create our own Aux by const aux = (props) => props.children;

this.setState((prevState, props) => {
      return {
        persons: [
          { name: newName, age: 5},
          { name: 'Logan Paul', age: 24},
          { name: 'Mike Majlak', age: 35},
        ],
        changeCounter : prevState.changeCounter + 1
      }
    })

here instead of using 
this.setState({
  persons : persons,
  changeCounter : this.changeCounter +1
})

we used the first option becuase even though setState is a sync function it takes sometime for updating state when change relies on the previous state
suppose state is being changed at the same time on 2 diff places of app so, it would create problems
so better way is using upper version

PropTypes is a really good package to help create good prop checks
import PropTypes from 'prop-types';
Based on function or classs based component, name sure propTypes here is lowercase
Person.propTypes = {
  onChange: PropTypes.func,
  name: PropTypes.string,
  age: PropTypes.number,
}

WAYS OF CREATING REFS IN Components
for Class based
constructor (props) {
      super(props);
      this.inputElementRef = React.createRef();
  }

componentDidMount () {
    // document.querySelector('input').focus(); 
    // but there is problem in using document approach because it focuses the first input of whole dom
    // this doesn't care about react, or doesn't care about the last element rendered

    // this.inputElement.focus();
    this.inputElementRef.current.focus();
}
// now inside the component
// by the way ref is assigned keyword of react
ref={this.inputElementRef}

// Functional based approach is diffrent
here we use useRef react hook
const toggleBtnRef = useRef(null);
 then in function useEffect, we use this function because this fun gets called after ever render cycle
 add
 toggleBtnRef.current.click();
 add ref = {toggleBtnRef}

USING CONTEXT
Generally used when props have to be run down from one component to other ,so, to avoid it from coming to different components where it has no use we use context
import React from 'react';

// we decide where this object will be available
// we can also initialize the value with a array or string not necesseraily object
const authContext = React.createContext({
    authenticated : false,
    login : () => {}
});

export default authContext;

first we create a context
then we create a Producer and a Consumer
<AuthContext.Provider value={{authenticated: this.state.authenticated, login: this.loginHandler}}
then we need the consumer
we use a function to return the jsx
<AuthContext.Consumer> {(context) => return some jsx} <AuthContext.Consumer>

Alternate method of consuming context will be
like if we want to use context outside returned jsx like in component did mount function then we will use

static contextType = AuthContext;

this.context.authenticated
but the above approach is nly usable in Class based components ,for function ones we use Use Hooks like useContext hook
const authContext = useContext(AuthContext);

let transformedIngredients = Object.keys(props.ingredients).map(
        igKey => {
            return [...Array(props.ingredients[igKey])].map((_, i) => {
                return <BurgerIngredients key={igKey + i} type={igKey} />;
            });
        }
    )
this is a really cool way to work with objects
first we extracted a array of keys using object.keys function
then we mapped through that array
console.log([...Array(2)]); gives [undefines, undefined]
we just needed the amount of times the BurgerIngredients component would have to be called
key property is necesarry when u use map to output components

we can use reduce method to flaten the arrays, what does flaten mean
means that if arrays have inner arrays we want to creatae one big array of all

go to video 147
if shows in logo how diffrent classes of same name and same component would be treated difrently by react 

we can add lifecycle methods only in class based components
we can save performance by chacking components that are unnececerily rerendered and then handling that

to improve performance , we used shouldComponentUpdate so, the component only updates under a certain condition